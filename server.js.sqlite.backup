const express = require('express');
const path = require('path');
const cors = require('cors');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const axios = require('axios');
require('dotenv').config();

const db = require('./database');
const app = express();

app.use(cors());
app.use(express.json());

// Request Logger
app.use((req, res, next) => {
    console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
    next();
});

const PORT = process.env.PORT || 3000;
const PAYSTACK_SECRET = process.env.PAYSTACK_SECRET_KEY;
const JWT_SECRET = process.env.JWT_SECRET || 'supersecretkeychangedinproduction';

// Constants
const PAYSTACK_UNIT = 100;
const SIGNUP_FEE_KES = 100;
const REFERRAL_REWARD_KES = 50;
const SIGNUP_FEE_UNITS = SIGNUP_FEE_KES * PAYSTACK_UNIT;
const REFERRAL_REWARD_UNITS = REFERRAL_REWARD_KES * PAYSTACK_UNIT;

if (!PAYSTACK_SECRET) {
    console.error('Missing PAYSTACK_SECRET_KEY');
}

// --- Middleware ---
function authenticateToken(req, res, next) {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (!token) return res.sendStatus(401);

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) return res.sendStatus(403);
        req.user = user;
        next();
    });
}

function requireAdmin(req, res, next) {
    db.get("SELECT is_admin FROM users WHERE id = ?", [req.user.id], (err, row) => {
        if (err || !row || row.is_admin !== 1) {
            return res.status(403).json({ message: 'Admin access required' });
        }
        next();
    });
}

// --- Auth Endpoints ---
app.post('/auth/signup', async (req, res) => {
    const { email, password, referralCode } = req.body;
    if (!email || !password) return res.status(400).json({ message: 'Email and password required' });

    const hashedPassword = await bcrypt.hash(password, 10);
    const userRefCode = 'USER' + Date.now().toString().slice(-6);

    // Find referrer
    let referrerId = null;
    if (referralCode) {
        referrerId = await new Promise((resolve) => {
            db.get("SELECT id FROM users WHERE referral_code = ?", [referralCode], (err, row) => {
                resolve(row ? row.id : null);
            });
        });
    }

    // Check if this is the first user ever
    db.get("SELECT count(*) as count FROM users", [], (err, row) => {
        const isAdmin = (row && row.count === 0) ? 1 : 0;

        db.run(
            `INSERT INTO users (email, password_hash, referral_code, referred_by, is_admin) VALUES (?, ?, ?, ?, ?)`,
            [email, hashedPassword, userRefCode, referrerId, isAdmin],
            function (err) {
                if (err) {
                    if (err.message.includes('UNIQUE')) return res.status(400).json({ message: 'Email already exists' });
                    return res.status(500).json({ message: 'Database error' });
                }
                const userId = this.lastID;

                db.run(`INSERT INTO wallets (user_id) VALUES (?)`, [userId]); // Create Wallet

                const token = jwt.sign({ id: userId, email }, JWT_SECRET, { expiresIn: '1h' });
                res.status(201).json({ token, needsPayment: true, user: { id: userId, email, referralCode: userRefCode } });
            }
        );
    });
});

app.post('/auth/login', (req, res) => {
    const { email, password } = req.body;

    db.get("SELECT * FROM users WHERE email = ?", [email], async (err, user) => {
        if (err) return res.status(500).json({ message: 'Db error' });
        if (!user) return res.status(400).json({ message: 'Invalid credentials' });

        if (await bcrypt.compare(password, user.password_hash)) {
            const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: '1h' });
            res.json({ token, needsPayment: !user.is_paid });
        } else {
            res.status(400).json({ message: 'Invalid credentials' });
        }
    });
});

app.post('/auth/update-password', authenticateToken, async (req, res) => {
    const { newPassword } = req.body;
    if (!newPassword || newPassword.length < 6) return res.status(400).json({ message: 'Password must be at least 6 characters' });

    const hashedPassword = await bcrypt.hash(newPassword, 10);
    const userId = req.user.id;

    db.run("UPDATE users SET password_hash = ? WHERE id = ?", [hashedPassword, userId], (err) => {
        if (err) return res.status(500).json({ message: 'Database error' });
        res.json({ success: true, message: 'Password updated successfully' });
    });
});

// --- Wallet / Dashboard Endpoints ---
app.get('/dashboard/data', authenticateToken, (req, res) => {
    const userId = req.user.id;

    db.get("SELECT is_paid, referral_code, is_admin FROM users WHERE id = ?", [userId], (err, user) => {
        if (!user) return res.sendStatus(404);

        db.get("SELECT balance_units FROM wallets WHERE user_id = ?", [userId], (err, wallet) => {
            db.all("SELECT * FROM referrals WHERE referrer_id = ?", [userId], (err, referrals) => {
                res.json({
                    user: {
                        email: req.user.email,
                        referralCode: user.referral_code,
                        isPaid: !!user.is_paid,
                        isAdmin: !!user.is_admin
                    },
                    wallet: {
                        balanceKES: (wallet ? wallet.balance_units : 0) / PAYSTACK_UNIT
                    },
                    referrals: referrals || []
                });
            });
        });
    });
});

// --- Payment & Verification ---

// Initiate Payment (Create Pending Tx)
app.post('/pay/initiate', authenticateToken, (req, res) => {
    const userId = req.user.id;
    const reference = 'REF_' + Date.now() + '_' + userId;
    const amountUnits = SIGNUP_FEE_UNITS;

    db.run(
        `INSERT INTO transactions (reference, user_id, amount_units, currency, status, metadata) VALUES (?, ?, ?, ?, 'pending', ?)`,
        [reference, userId, amountUnits, 'KES', JSON.stringify({ type: 'signup' })],
        function (err) {
            if (err) return res.status(500).json({ message: 'Tx creation failed' });
            // Using Test Key for development
            res.json({ reference, amount: amountUnits, key: 'pk_test_e61df53001707bcf5afe0fbfa20d361c209311f1' });
        }
    );
});

// Simple endpoint to manually mark user as paid (for test payments)
app.post('/pay/mark-paid', authenticateToken, (req, res) => {
    const userId = req.user.id;
    console.log(`[MARK-PAID] Attempting to mark user ${userId} as paid`);

    db.run("UPDATE users SET is_paid = 1 WHERE id = ?", [userId], function (err) {
        if (err) {
            console.error('[MARK-PAID] Database error:', err);
            return res.status(500).json({ message: 'Failed to update', error: err.message });
        }

        console.log(`[MARK-PAID] Successfully updated user ${userId}, rows affected: ${this.changes}`);
        res.json({ success: true, userId, rowsAffected: this.changes });
    });
});

// Verify Endpoint
app.get('/verify/:reference', async (req, res) => {
    const reference = req.params.reference;
    if (!reference) return res.status(400).json({ verified: false, message: 'No reference' });

    try {
        const resp = await axios.get(`https://api.paystack.co/transaction/verify/${reference}`, {
            headers: { Authorization: `Bearer ${PAYSTACK_SECRET}` }
        });

        const d = resp.data;
        if (d && d.status && d.data && d.data.status === 'success') {
            await processSuccessfulPayment(d.data);
            return res.json({ verified: true, data: d.data });
        } else {
            return res.json({ verified: false, message: 'Payment not successful' });
        }
    } catch (err) {
        console.error('Verify error', err.message);
        return res.status(500).json({ verified: false, message: 'Verification error' });
    }
});

// Webhook
app.post('/webhook/paystack', async (req, res) => {
    const signature = req.headers['x-paystack-signature'];
    const secret = PAYSTACK_SECRET;
    const payload = JSON.stringify(req.body);

    const hmac = crypto.createHmac('sha512', secret).update(payload).digest('hex');
    if (hmac !== signature) return res.status(400).send('Invalid signature');

    const event = req.body;
    if (event.event === 'charge.success') {
        await processSuccessfulPayment(event.data);
    }
    res.status(200).send('OK');
});

// --- NEW FEATURES ---

// Task Completion
app.post('/tasks/complete', authenticateToken, (req, res) => {
    const { taskType, reward } = req.body;
    const userId = req.user.id;
    const rewardAmount = parseInt(reward) * PAYSTACK_UNIT; // Convert KES to units

    if (!rewardAmount || rewardAmount <= 0) return res.status(400).json({ message: 'Invalid reward' });

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        db.run("INSERT INTO task_logs (user_id, task_type, amount) VALUES (?, ?, ?)", [userId, taskType, rewardAmount], (err) => {
            if (err) { db.run("ROLLBACK"); return res.status(500).json({ message: 'Failed to log' }); }

            db.run("UPDATE wallets SET balance_units = balance_units + ? WHERE user_id = ?", [rewardAmount, userId], (err) => {
                if (err) { db.run("ROLLBACK"); return res.status(500).json({ message: 'Failed to update wallet' }); }

                db.run("COMMIT");
                db.get("SELECT balance_units FROM wallets WHERE user_id = ?", [userId], (err, row) => {
                    res.json({ success: true, newBalance: row.balance_units / PAYSTACK_UNIT });
                });
            });
        });
    });
});

// Withdraw Request
app.post('/withdraw', authenticateToken, (req, res) => {
    const { amount, phone } = req.body;
    const userId = req.user.id;
    const withdrawAmount = parseInt(amount) * PAYSTACK_UNIT;

    if (!withdrawAmount || withdrawAmount < (150 * PAYSTACK_UNIT)) return res.status(400).json({ message: 'Minimum 150 KES' });

    db.serialize(() => {
        db.run("BEGIN TRANSACTION");
        db.get("SELECT balance_units FROM wallets WHERE user_id = ?", [userId], (err, wallet) => {
            if (err || !wallet || wallet.balance_units < withdrawAmount) {
                db.run("ROLLBACK");
                return res.status(400).json({ message: 'Insufficient balance' });
            }

            db.run("UPDATE wallets SET balance_units = balance_units - ? WHERE user_id = ?", [withdrawAmount, userId], (err) => {
                if (err) { db.run("ROLLBACK"); return res.status(500).json({ message: 'Failed deduct' }); }

                db.run("INSERT INTO withdrawals (user_id, amount, phone) VALUES (?, ?, ?)", [userId, withdrawAmount / PAYSTACK_UNIT, phone], (err) => {
                    if (err) { db.run("ROLLBACK"); return res.status(500).json({ message: 'Failed create' }); }
                    db.run("COMMIT");
                    res.json({ success: true });
                });
            });
        });
    });
});

// ========== COURSE SYSTEM ENDPOINTS ==========

// PUBLIC: Get all published courses
app.get('/courses', (req, res) => {
    db.all(`SELECT c.id, c.title, c.description, c.thumbnail_url, c.price, c.duration_hours,
            (SELECT COUNT(*) FROM lessons WHERE course_id = c.id) as lesson_count
            FROM courses c WHERE c.is_published = 1 ORDER BY c.created_at DESC`, [], (err, courses) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(courses.map(c => ({ ...c, priceKES: c.price / 100 })));
    });
});

// PUBLIC: Get course details with lessons
app.get('/courses/:id', (req, res) => {
    const courseId = req.params.id;

    db.get(`SELECT * FROM courses WHERE id = ? AND is_published = 1`, [courseId], (err, course) => {
        if (err) return res.status(500).json({ error: err.message });
        if (!course) return res.status(404).json({ message: 'Course not found' });

        db.all(`SELECT id, title, duration_minutes, order_index FROM lessons 
                WHERE course_id = ? ORDER BY order_index ASC`, [courseId], (err, lessons) => {
            res.json({ ...course, priceKES: course.price / 100, lessons });
        });
    });
});

// USER: Check if user owns a course
app.get('/courses/:id/access', authenticateToken, (req, res) => {
    const userId = req.user.id;
    const courseId = req.params.id;

    db.get(`SELECT id FROM course_purchases WHERE user_id = ? AND course_id = ?`, [userId, courseId], (err, purchase) => {
        res.json({ hasAccess: !!purchase });
    });
});

// USER: Get my purchased courses
app.get('/my-courses', authenticateToken, (req, res) => {
    const userId = req.user.id;

    db.all(`SELECT c.*, cp.purchased_at,
            (SELECT COUNT(*) FROM lessons WHERE course_id = c.id) as total_lessons,
            (SELECT COUNT(*) FROM lesson_progress lp 
             JOIN lessons l ON lp.lesson_id = l.id 
             WHERE l.course_id = c.id AND lp.user_id = ? AND lp.completed = 1) as completed_lessons
            FROM courses c
            JOIN course_purchases cp ON c.id = cp.course_id
            WHERE cp.user_id = ?
            ORDER BY cp.purchased_at DESC`, [userId, userId], (err, courses) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(courses.map(c => ({
            ...c,
            priceKES: c.price / 100,
            progress: c.total_lessons > 0 ? Math.round((c.completed_lessons / c.total_lessons) * 100) : 0
        })));
    });
});

// USER: Initiate course purchase
app.post('/courses/:id/purchase', authenticateToken, (req, res) => {
    const userId = req.user.id;
    const courseId = req.params.id;

    // Check if already purchased
    db.get(`SELECT id FROM course_purchases WHERE user_id = ? AND course_id = ?`, [userId, courseId], (err, existing) => {
        if (existing) return res.status(400).json({ message: 'Course already purchased' });

        // Get course price
        db.get(`SELECT price, title FROM courses WHERE id = ? AND is_published = 1`, [courseId], (err, course) => {
            if (!course) return res.status(404).json({ message: 'Course not found' });

            const reference = 'COURSE_' + courseId + '_' + Date.now() + '_' + userId;

            db.run(`INSERT INTO transactions (reference, user_id, amount_units, currency, status, metadata) 
                    VALUES (?, ?, ?, 'KES', 'pending', ?)`,
                [reference, userId, course.price, JSON.stringify({ type: 'course_purchase', course_id: courseId })],
                function (err) {
                    if (err) return res.status(500).json({ message: 'Transaction creation failed' });
                    res.json({
                        reference,
                        amount: course.price,
                        key: 'pk_test_e61df53001707bcf5afe0fbfa20d361c209311f1',
                        courseTitle: course.title
                    });
                }
            );
        });
    });
});

// USER: Verify course payment (callback after Paystack)
app.post('/courses/verify-payment', authenticateToken, async (req, res) => {
    const { reference } = req.body;
    const userId = req.user.id;

    try {
        const resp = await axios.get(`https://api.paystack.co/transaction/verify/${reference}`, {
            headers: { Authorization: `Bearer ${PAYSTACK_SECRET}` }
        });

        const data = resp.data;
        if (data && data.status && data.data && data.data.status === 'success') {
            // Get transaction metadata
            db.get(`SELECT metadata FROM transactions WHERE reference = ?`, [reference], (err, tx) => {
                if (!tx) return res.status(404).json({ message: 'Transaction not found' });

                const meta = JSON.parse(tx.metadata);
                if (meta.type !== 'course_purchase') return res.status(400).json({ message: 'Invalid transaction type' });

                const courseId = meta.course_id;

                // Grant access
                db.run(`INSERT OR IGNORE INTO course_purchases (user_id, course_id, amount_paid, transaction_ref)
                        VALUES (?, ?, ?, ?)`, [userId, courseId, data.data.amount, reference], (err) => {
                    if (err) return res.status(500).json({ message: 'Failed to grant access' });

                    // Update transaction status
                    db.run(`UPDATE transactions SET status = 'success' WHERE reference = ?`, [reference]);

                    res.json({ success: true, message: 'Course purchased successfully!', courseId });
                });
            });
        } else {
            res.json({ success: false, message: 'Payment verification failed' });
        }
    } catch (err) {
        console.error('Course payment verification error:', err.message);
        res.status(500).json({ success: false, message: 'Verification error' });
    }
});

// USER: Update lesson progress
app.post('/lessons/:id/progress', authenticateToken, (req, res) => {
    const userId = req.user.id;
    const lessonId = req.params.id;
    const { completed, watched_seconds } = req.body;

    // Check if user owns the course this lesson belongs to
    db.get(`SELECT l.course_id FROM lessons l WHERE l.id = ?`, [lessonId], (err, lesson) => {
        if (!lesson) return res.status(404).json({ message: 'Lesson not found' });

        db.get(`SELECT id FROM course_purchases WHERE user_id = ? AND course_id = ?`, [userId, lesson.course_id], (err, purchase) => {
            if (!purchase) return res.status(403).json({ message: 'Access denied' });

            db.run(`INSERT INTO lesson_progress (user_id, lesson_id, completed, watched_seconds, updated_at)
                    VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
                    ON CONFLICT(user_id, lesson_id) DO UPDATE SET
                    completed = ?, watched_seconds = ?, updated_at = CURRENT_TIMESTAMP`,
                [userId, lessonId, completed ? 1 : 0, watched_seconds || 0, completed ? 1 : 0, watched_seconds || 0],
                (err) => {
                    if (err) return res.status(500).json({ error: err.message });
                    res.json({ success: true });
                }
            );
        });
    });
});

// ADMIN: Create new course
app.post('/admin/courses', authenticateToken, requireAdmin, (req, res) => {
    const { title, description, thumbnail_url, price, duration_hours } = req.body;
    const adminId = req.user.id;
    const priceUnits = parseInt(price) * 100;

    if (!title || !price) return res.status(400).json({ message: 'Title and price required' });

    db.run(`INSERT INTO courses (title, description, thumbnail_url, price, duration_hours, created_by)
            VALUES (?, ?, ?, ?, ?, ?)`,
        [title, description, thumbnail_url || '', priceUnits, duration_hours || 0, adminId],
        function (err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true, courseId: this.lastID });
        }
    );
});

// ADMIN: Update course
app.put('/admin/courses/:id', authenticateToken, requireAdmin, (req, res) => {
    const { title, description, thumbnail_url, price, duration_hours } = req.body;
    const courseId = req.params.id;
    const priceUnits = price ? parseInt(price) * 100 : null;

    db.run(`UPDATE courses SET 
            title = COALESCE(?, title),
            description = COALESCE(?, description),
            thumbnail_url = COALESCE(?, thumbnail_url),
            price = COALESCE(?, price),
            duration_hours = COALESCE(?, duration_hours)
            WHERE id = ?`,
        [title, description, thumbnail_url, priceUnits, duration_hours, courseId],
        (err) => {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true });
        }
    );
});

// ADMIN: Delete course
app.delete('/admin/courses/:id', authenticateToken, requireAdmin, (req, res) => {
    db.run(`DELETE FROM courses WHERE id = ?`, [req.params.id], (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// ADMIN: Toggle publish status
app.put('/admin/courses/:id/publish', authenticateToken, requireAdmin, (req, res) => {
    const { is_published } = req.body;
    db.run(`UPDATE courses SET is_published = ? WHERE id = ?`, [is_published ? 1 : 0, req.params.id], (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// ADMIN: Add lesson to course
app.post('/admin/courses/:id/lessons', authenticateToken, requireAdmin, (req, res) => {
    const courseId = req.params.id;
    const { title, video_url, order_index, duration_minutes } = req.body;

    if (!title) return res.status(400).json({ message: 'Lesson title required' });

    db.run(`INSERT INTO lessons (course_id, title, video_url, order_index, duration_minutes)
            VALUES (?, ?, ?, ?, ?)`,
        [courseId, title, video_url || '', order_index || 0, duration_minutes || 0],
        function (err) {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true, lessonId: this.lastID });
        }
    );
});

// ADMIN: Update lesson
app.put('/admin/lessons/:id', authenticateToken, requireAdmin, (req, res) => {
    const { title, video_url, order_index, duration_minutes } = req.body;
    const lessonId = req.params.id;

    db.run(`UPDATE lessons SET
            title = COALESCE(?, title),
            video_url = COALESCE(?, video_url),
            order_index = COALESCE(?, order_index),
            duration_minutes = COALESCE(?, duration_minutes)
            WHERE id = ?`,
        [title, video_url, order_index, duration_minutes, lessonId],
        (err) => {
            if (err) return res.status(500).json({ error: err.message });
            res.json({ success: true });
        }
    );
});

// ADMIN: Delete lesson
app.delete('/admin/lessons/:id', authenticateToken, requireAdmin, (req, res) => {
    db.run(`DELETE FROM lessons WHERE id = ?`, [req.params.id], (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// ADMIN: Get all courses (including unpublished)
app.get('/admin/courses', authenticateToken, requireAdmin, (req, res) => {
    db.all(`SELECT c.*,
            (SELECT COUNT(*) FROM lessons WHERE course_id = c.id) as lesson_count,
            (SELECT COUNT(*) FROM course_purchases WHERE course_id = c.id) as purchase_count
            FROM courses c ORDER BY c.created_at DESC`, [], (err, courses) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json(courses.map(c => ({ ...c, priceKES: c.price / 100 })));
    });
});

// Admin Data
app.get('/admin/data', (req, res) => {
    db.serialize(() => {
        db.all("SELECT id, email, is_paid, referral_code FROM users ORDER BY id DESC", [], (err, users) => {
            if (err) return res.status(500).json({ error: err.message });

            db.all("SELECT w.id, w.amount, w.phone, w.status, u.email FROM withdrawals w JOIN users u ON w.user_id = u.id ORDER BY w.id DESC", [], (err, withdrawals) => {
                res.json({ users, withdrawals });
            });
        });
    });
});

app.post('/admin/withdraw/:id/action', (req, res) => {
    const { action } = req.body;
    const id = req.params.id;
    const status = action === 'approve' ? 'approved' : 'rejected';

    db.run("UPDATE withdrawals SET status = ? WHERE id = ?", [status, id], (err) => {
        if (err) return res.status(500).json({ error: err.message });
        res.json({ success: true });
    });
});

// Core Business Logic (Atomic)
async function processSuccessfulPayment(paystackData) {
    const reference = paystackData.reference;

    return new Promise((resolve, reject) => {
        db.serialize(() => {
            db.run("BEGIN TRANSACTION");

            // Check if tx exists and is already success
            db.get("SELECT * FROM transactions WHERE reference = ?", [reference], (err, tx) => {
                if (err || (tx && tx.status === 'success')) {
                    db.run("ROLLBACK");
                    return resolve(); // Idempotent exit
                }

                // If tx doesn't exist (webhook came first?), create it. Or update existing.
                // For simplicity, we assume /pay/initiate created it, so we update.
                // If not found, we insert.
                const meta = tx ? JSON.parse(tx.metadata) : { type: 'unknown' };

                const updateTx = tx
                    ? `UPDATE transactions SET status = 'success' WHERE id = ?`
                    : `INSERT INTO transactions (reference, status, amount_units, currency, metadata) VALUES (?, 'success', ?, ?, ?)`;
                const params = tx ? [tx.id] : [reference, paystackData.amount, paystackData.currency, JSON.stringify(paystackData)];

                db.run(updateTx, params, function (err) {
                    if (err) { db.run("ROLLBACK"); return resolve(); }

                    // If Signup -> Activate User
                    if (meta.type === 'signup') {
                        const userId = tx ? tx.user_id : null; // If webhook created tx, we might need logic to find user. Assuming initiate flow for now.
                        if (userId) {
                            db.run("UPDATE users SET is_paid = 1 WHERE id = ?", [userId]);

                            // Referral Reward Logic
                            db.get("SELECT referred_by FROM users WHERE id = ?", [userId], (err, user) => {
                                if (user && user.referred_by) {
                                    // Check if already paid referral
                                    db.get("SELECT id FROM referrals WHERE referred_user_id = ?", [userId], (err, refRow) => {
                                        if (!refRow) {
                                            // Credit Referrer
                                            const reward = REFERRAL_REWARD_UNITS;
                                            db.run(`UPDATE wallets SET balance_units = balance_units + ? WHERE user_id = ?`, [reward, user.referred_by]);

                                            // Record Transaction for Referrer
                                            const refTxRef = 'REF_BONUS_' + userId + '_' + Date.now();
                                            db.run(`INSERT INTO transactions (reference, user_id, amount_units, status, metadata) VALUES (?, ?, ?, 'success', ?)`,
                                                [refTxRef, user.referred_by, reward, JSON.stringify({ type: 'referral_bonus', source: userId })],
                                                function () {
                                                    const newTxId = this.lastID;
                                                    // Add Referral Record
                                                    db.run(`INSERT INTO referrals (referrer_id, referred_user_id, reward_units, status, awarded_tx_id) VALUES (?, ?, ?, 'paid', ?)`,
                                                        [user.referred_by, userId, reward, newTxId]);
                                                }
                                            );
                                        }
                                    });
                                }
                            });
                        }
                    }

                    db.run("COMMIT", () => resolve());
                });
            });
        });
    });
}


// Serve static files last (fallback)
app.use(express.static(path.join(__dirname)));
app.listen(PORT, '0.0.0.0', () => console.log(`Server running on port ${PORT}`));
